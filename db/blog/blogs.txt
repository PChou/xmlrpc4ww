id#filename#content#title#layout#description#thumbimg#categories#tags#createdate#moddate#
inc#str#str#str#str#str#str#str#str#str#str#
1#filename#content#title#layout#description#thumbimg#categories#tags#createdate#moddate#
4#2013-10-23-526712a543031.html#<h1>缘起</h1> <p>在之前的文章<a href="http://pchou.info/web-build/2013/01/20/build-github-blog-page-07.html">一步步在GitHub上创建博客主页(7)--兼容Windows Writer的服务提供器</a>中，为了使编写博客和发布博客更加方便，我实现了一个windows writer的服务提供器，基于.NET和XML-RPC.NET。在实际使用过程中其实遇到不少问题，比如文章的二次编辑修改将无法支持，多个windows writer客户端无法同步编辑，提供器部署复杂等。思考下来觉得还是得有数据库支持，而且要尽可能的方便部署和同步数据。于是决定用PHP重新实现一个，PHP有以下特点：</p> <ul> <li>轻巧，部署方便  <li>能够轻便的支持基于文本的数据库，可以实现多客户端“分布式编辑”</li></ul> <p>&nbsp;</p> <h1>系统运作方式</h1> <p>假设用户现在只有一台PC1用来写blog，系统运行机制如下：</p> <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-23-5267cbc7d3656.png" width="313" height="440"></p> <ol> <li>在PC1上克隆好了github page的项目  <li>用户在PC1上部署一个PHP站点，并配置指向上面的github page的项目目录  <li>在PC1上使用windows writer配置这个站点为日志帐户  <li>在PC1上使用windows writer编写文章  <li>在PC1上将文章发布到PHP站点  <li>打开PHP站点的页面，修改分类、标签等必要信息，点击发布，PHP站点将把文章创建在github page的项目目录的对应文件夹中（包括图片）  <li>（可选）用jekyll测试页面，返回4，直到满意  <li>在PC1上使用git将github page的项目push到github</li></ol> <p>图中黄色的2、3步骤是一次性的配置工作，以后不需要重复进行。另外可以看到这里的PHP站点起到了“代理”的作用，因为github不能支持windows writer嘛，所以只能依靠代理了；而且这个代理是在你PC本机的，链接你的Writer和本地的仓库。</p> <p>&nbsp;</p> <p>如果你在家中和公司各有一台PC，可能希望在两台PC上都能编写博客，甚至发布博客，而这个代理是本机的，如何能实现在博客正式发布前”共享“呢？答案是文本数据库。来看多客户端情况下的工作机制（左边是之前的PC1）：</p> <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-23-5267ce0633ef9.png" width="545" height="426"></p> <ul style="list-style-type: none"> <li>1.这个PHP站点包含一个基于文本的数据库，用来存放每一篇发布到PHP站点的文章。<font color="%hff0000">并将这个PHP站点本身作为一个仓库推送到github</font>  <li>2.在另一台PC2上克隆或拉取仓库代码（包括文本数据库）  <li>3～5步跟上面的1～3相同，克隆或拉取github page所在仓库，配置PHP站点，配置writer  <li>6.利用writer的”打开远程文章“的功能，从PHP站点上得到文章标题、内容等  <li>7.继续编辑文章  <li>8.将文章发布到PHP站点  <li>9.打开PHP站点的页面，修改分类、标签等必要信息，点击发布，PHP站点将把文章创建在github page的项目目录的对应文件夹中（包括图片）  <li>10.（可选）用jekyll测试页面，返回7，直到满意  <li>11.在PC2上使用git将github page的项目push到github</li></ul> <p>&nbsp;</p> <p>通过上面的步骤可以继续编辑文章，达到共享的目的。起作用的关键其实是，PHP站点利用文本数据库和站点本身作为仓库这两点，保存了在PC1上的文章内容，可供PC2克隆或拉取。同理，也可以将PC2的PHP站点（及其数据文件）推送到github上，供PC1继续编辑发布。</p> <p>&nbsp;</p> <p>本文介绍了系统的工作机制。虽说有了这套东西，写博客会方便不少，但是操作还是比较琐碎的，因此需要对工作机制有比较清晰的了解，这对于用户来说是十分重要的。下一篇将指导用户具体操作过程。</p>#基于PHP的Windows Writer服务提供器--介绍#postlayout#介绍一个支持Windows Writer的PHP服务的实现和运行机制，有了这个PHP服务，用Writer来编写博客，插入图片就简单方便许多了。#1346208288725.jpg#[web-build]#[PHP,github-page]#2013-10-23 08:04:53#2013-10-27 22:01:24#
5#2013-10-23-5267e1c65917c.html#<p>在<a href="http://pchou.info/web-build/2013/10/23/526712a543031.html" target="_blank">上一篇</a>中介绍了系统的运行机制，本文将引导读者一步步部署并使用。首先，假设您已经完成了github博客的搭建工作，并理解基本的博客维护方式以及jekyll的基本原理和使用方法。</p> <p>&nbsp;</p> <h2>部署本地的PHP站点</h2> <p>PHP项目的主页地址：<a href="https://github.com/PChou/xmlrpc4ww">https://github.com/PChou/xmlrpc4ww</a></p> <p>用您自己的帐户登录github，在浏览器中键入上述地址，点击页面右上方的<code>Fork</code>。Fork的意思是将这个项目复制到您自己的代码仓库中，您就可以自由的修改编辑了，还能在需要的时候对原代码仓库贡献代码，或者同步原代码仓库的变化。</p> <p>将Fork出来的仓库clone到本地,，这地址应该像下面这样：</p><pre>git clone https://github.com/<em>{yourusername}</em>/xmlrpc4ww.git</pre>%n<p>项目目录中的文件结构如下（省略无关紧要的文件）</p><pre>/xmlrpc4ww%n  |--content //存放js和css%n  |--db%n      |--blog	//文本数据库%n           |--__blogs.txt //数据文件模板%n           |--blogs.txt	//数据文件%n  |--txtdb	//文本数据库支持库%n  |--xmlrpc	//xmlrpc api支持库%n  |--__config.php   //配置文件模板%n  |--post.php       //文章发布页面%n  |--postlist.php   //文章列表页面%n  |--server.php     //writer服务提供页面和文章列表入口%n  |--util2.php      //支持方法%n</pre>%n<p>将__config.php在同一目录复制一份，取名为<code>config.php</code>，修改config.php：</p><pre>define("LOCALPATH", "D:\\Project\\Git\\NRemedy");    \\本地github page项目所在目录，注意双斜杠%ndefine("IMGPATH", "assert\\img");		     \\图片的相对路径，此处就表示我的博客的图片规划在D:\Project\Git\NRemedy\assert\img下，注意双斜杠%ndefine("IMGPATH2", "/assert/img/");		     \\图片的url相对路径，与上面应对应，但注意斜杠的方向%n%ndefine("DEFAULT_LAYOUT", "postlayout");		      \\每个post的jekyll模板使用的默认的layout名称，配置这个后可以简化将来发布填写的东西%n%ndefine("BLOGNAME", "ghpage");			     \\blog名称，可以不作修改%ndefine("BLOGID","67322");			     \\blogid，可以不作修改%ndefine("BLOGURL","http://fakelocalhost");            \\blog地址，不要修改，保持fakelocalhost%n%n%n</pre>%n<p><font color="%hff0000">注意：上面的前三项务必配置准确，否则将无法正常使用</font></p>%n<p>删除<code>db/blog/blogs.txt</code>，将<code>__blogs.txt</code>重命名为<code>blogs.txt</code>。原先的blogs.txt是我的文章数据库，您需要的是空的数据库文件，所以从__blogs.txt这个空的数据文件模板开始，完成之后您的目录结构将是这样：</p><pre>/xmlrpc4ww%n  |--content //存放js和css%n  |--db%n      |--blogs	//文本数据库%n           |--blogs.txt	//空数据文件%n  |--txtdb	//文本数据库支持库%n  |--xmlrpc	//xmlrpc api支持库%n  |--config.php     //配置文件模板%n  |--post.php       //文章发布页面%n  |--postlist.php   //文章列表页面%n  |--server.php     //writer服务提供页面和文章列表入口%n  |--util2.php      //支持方法%n</pre>%n<p>接下来要做的是配置一个php运行环境，如果您已经配置过php环境，那么恭喜你，可以跳过这个步骤了。下载并安装php环境，读者可参考<a href="http://www.cnblogs.com/zengxiangzhan/archive/2010/03/05/1679286.html">http://www.cnblogs.com/zengxiangzhan/archive/2010/03/05/1679286.html</a></p>%n<p>&nbsp;</p>%n<p>在IIS中创建一个站点，指向xmlrpc4ww，启动该网站，并用浏览器访问<a href="http://localhost{:port}/server.php">http://localhost<em>{:port}</em>/server.php</a>，看到如下页面说明php站点部署完毕（请注意，您的端口可能与我不同）</p>%n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="559EHMUA36]Z76X}}OP0V`L" border="0" alt="559EHMUA36]Z76X}}OP0V`L" src="http://fakelocalhost/assert/img/2013-10-23-5267e1c64ed6a.jpeg" width="638" height="28"> %n<p>&nbsp;</p>%n<h2>配置Windows Writer</h2>%n<p>点击“添加日志帐户”，选择“其他服务”</p><img style="display: inline" class="img-responsive" title="image" alt="image" src="http://fakelocalhost/assert/img/2013-01-20-build-github-blog-page-07-img1.png" width="403" height="379"> %n<p>按照下图输入日志网址，注意，你本机的PHP站点的端口可能与我不同，用户名和密码随便填，无所谓，暂时不要记住密码</p>%n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-24-52692c3153e36.png" width="398" height="375"></p>%n<p>点击“下一步”，按下图填写，注意这里的远程发布网址是关键点，必须填写正确，还是一样，请注意您本机的端口可能与我不同</p>%n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-24-52692c315bb38.png" width="402" height="379"></p>%n<p>点击“下一步”，windows writer会开始检测服务端设置</p>%n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-24-52692c3165392.png" width="403" height="380"></p>%n<p>最后会成功提示如下，可以点击Yes，发布一个测试日志，如下图。至此Writer和PHP站点打通了</p>%n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-24-52692c316efd4.png" width="419" height="179"></p>%n<p>将来发布日志的时候请选择ghpage发布</p>%n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-24-52692c317594e.png" width="220" height="84"> %n<p>&nbsp;</p>%n<h2>将日志发布到本地的gh-page</h2>%n<p>用浏览器访问<a href="http://localhost{:port}/server.php">http://localhost<em>{:port}</em>/server.php</a>，应该看到多出一条记录，这条记录就是刚刚发布的临时日志。点击“编辑和发布”，显示类似下面的页面</p>%n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="JWAF752I~RH(OCJT5(`P`NT" border="0" alt="JWAF752I~RH(OCJT5(`P`NT" src="http://fakelocalhost/assert/img/2013-10-24-52692c317c2c7.jpeg" width="295" height="267"> %n<p>我们知道基于jekyll的post都应该有如下开头： <pre>---%nlayout: postlayout%ntitle: Hello GitHub!%ndescription: 该博客的开篇之文%nthumbimg: 1346208288725.jpg%ncategories: [life]%ntags: [github-page, jekyll]%n---%n</pre>%n<p>其中layout、title、categories、tags是jekyll默认支持的变量， 而且categories和tags有特定的格式。用户也可以自定义变量，可以在jekyll的post对象中获得这些变量。上面的description和thumnimg都是我自定义的变量，分别用于显示摘要和首页缩略图。 %n<p>与之对应的，上面的页面就是用来配置这些变量的。 %n<ul>%n<li>文件名是自动生成的，如果要修改的话请保持jekyll的日期规则，而且点击“保存并生成”后尽量不要再修改，否则，会生成两个日志； %n<li>标题来源于Writer中的标题，不能修改，只能由Writer发布上来； %n<li>layout的默认值来源与上面对PHP部署时的基础配置，应该修改成你希望的layout文件名； %n<li>分类和标签，请自行添加，但要符合jekyll规则</li></ul>%n<blockquote>%n<p>如果您的变量与我不同的话，需要自己修改php代码和数据库文件来支持。如果您希望修改的话，请将你fork的仓库地址发在下面的留言板里面，我可能考虑帮你修改。当然也许将来的版本我会发布一个可配置的版本</p></blockquote>%n<p>配置完成后，点击“保存并生成”，如果显示“成功”的话，恭喜您，文章已经在您本地的git仓库中拉。</p>%n<p>接下来您可以用本地的jekyll测试和发布你刚刚发布的文章，具体可以参考<a href="http://pchou.info/web-build/2013/01/05/build-github-blog-page-04.html">一步步在GitHub上创建博客主页(4)</a>以及相关的系列文章 %n<p>让我们来查看一下/xmlprc4ww/db/blogs.txt，此时，该文件应该已经包含了刚刚发布的日志以及post变量的配置等。顺便说一下，这个文件就是blogs的数据库文件，将来Writer从PHP站点获取或者写入的日志内容都将存放在这个文件中。 该文件除了前三行外，其他行都是数据，每一行由多个字段组成，每个字段用”%h“区隔，详见：<a href="http://www.c-worker.ch/txtdbapi/index.php">http://www.c-worker.ch/txtdbapi/index.php</a>&nbsp; <h2>&nbsp;</h2>%n<h2>编辑修改文章 </h2>%n<p>如果您的文章已经从Writer发布到PHP站点，甚至是发布到了github，但是此时需要修改一下，怎么办呢？很简单，您只需要在Writer中打开需要修改的文章，编辑好之后，点击发布，循环上面的步骤就可以了。 %n<blockquote>%n<p>您可能会发现再次打开后图片无法正常显示，这没关系，如果这导致Writer崩溃的话，请下载最新的Writer客户端；另外如果文章有图片的话在发布前请将图片“格式”设置成“链接至无”，否则会有两张图片上传到服务端</p></blockquote>%n<p>如果您只是用上面配置好的机器来编写博客的话，至此就足够了，下面介绍多客户端该怎么协同编辑。 %n<p>&nbsp; <h2>多客户端编辑</h2>%n<p>也许读者已经猜到了，没错，只要将xmlrpc4ww这个项目也push到github的仓库就可以了！上文提到，xmlprc4ww/db/blogs.txt保存了文章的内容，该内容是与本地Writer的内容同步的，于是只要将这个文件push到github上，然后在另外一台机器上pull过来，并且重复一次配置工作（包括站点配置、writer配置）就可以获得文章内容了。而在Writer的客户端上只要点击“打开最近使用过的日志”就可以从“另一个服务端”上获取文章内容了： %n<p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="image" border="0" alt="image" src="http://fakelocalhost/assert/img/2013-10-24-52692c3183411.png" width="390" height="285"> %n<blockquote>%n<p>特别需要注意的是，您PC2上的日志仓库可能与PC1不同，在配置PHP站点的时候需要特别留意 </p></blockquote>%n<p>&nbsp;</p>%n<h2>删除文章</h2>%n<p>xmlrpc4ww没有实现删除的功能，您可能需要手动完成，除了把github page所在的仓库中的日志文件和对应图片删除外，还需要删除xmlprc4ww/db/blogs.txt中的对应记录行。</p>%n<p>&nbsp;</p>%n<p>本文详细介绍了<a href="https://github.com/PChou/xmlrpc4ww" target="_blank">xmlrpc4ww</a>这个工具的使用方法，如果读者有任何问题，可以给我发邮件或者在下面留言，您的意见或建议是完善这个工具重要的途径，当然您也可以帮忙共享您的代码，发扬开源精神。</p>#基于PHP的Windows Writer服务提供器--如何使用#postlayout#详细描述如何配置php站点、如何配置Windows Writer、如何发布文章等细节#1346208288725.jpg#[web-build]#[PHP,github-page]#2013-10-23 22:48:38#2013-10-27 22:02:10#
6#2013-10-27-526d0f1648b1d.html#<p>公司部署网络环境，安装Esxi，去电脑城配了两台台式机当服务器，为了充分利用资源，准备安装Esxi。以前在公司里面也用PC装过Esxi，从来没有出过岔子。但是这次出了不少岔子。  <p>先是没有安装光盘，但是这个很快通过U盘引导解决了。具体使用的是一个叫unetbootin-windows-latest.exe工具，可以一键将iso写入U盘：  <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Image" border="0" alt="Image" src="http://fakelocalhost/assert/img/2013-10-27-526d0f162be26.png" width="449" height="332">  <p>然后，在安装过程中，报错说无法找到Network Adapter，寻寻觅觅，得知可能是vmware提供的安装包中没有我的网卡驱动，从这里可以查看自己的网卡是否被支持  <p><a href="http://www.vmware.com/resources/compatibility/search.php?deviceCategory=io">http://www.vmware.com/resources/compatibility/search.php?deviceCategory=io</a>  <p>如果不被支持的话必须，有三种解决途径  <p>1、如果是正规的品牌服务器的话，可以从服务器提供的光盘中找找有没有Esxi安装镜像，一般dell和hp都有提供各自定制化过的iso  <p>2、如果没有人家做好的iso的话，可以自己来做，去vmware网站上找驱动，然后用vmware提供的定制化iso工具ESXi-Customizer-v2.7.1，生成添加过驱动的iso  <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Image(1)" border="0" alt="Image(1)" src="http://fakelocalhost/assert/img/2013-10-27-526d0f1633f10.png" width="449" height="286">  <p>3、上面两种方法都没有成功的话，只能考虑重新购买被支持的网卡，intel的千兆网卡一般都支持，笔者从电脑城弄了一块就OK了  <p>网卡关过了以后，又碰到无法找到硬盘的问题，这个问题可能是由于两个原因：  <p>1、如果是用U盘引导的，在loading界面结束后，U盘就可以拔掉了，否则可能只识别出U盘  <p>2、可能需要在BIOS中设置SATA的工作方式为AHCI  <p>最后，还会有个警告说硬件不支持虚拟化技术，这时，需要将BIOS中的CPU开启虚拟化支持，具体操作由于BIOS版本很杂，自己找吧  <p>Esxi5.1激活码0F0KM-FLL4L-NZHG1-1CA56-9CU4J  <p>输入激活码的方法是在vSphere Client中，选择“配置”，然后选“已获选可的功能”，再点“编辑”就能看到输入序列号的界面了。  #Esxi安装手记#postlayout#网卡驱动、硬盘模式、CPU模式是安装Esxi经常碰到的问题。本文记录了实际在部署Esxi的时候碰到的这些困难和解决方案。#image0021229433128273.jpg#[hardware]#[Esxi,iso,Driver]#2013-10-27 21:03:18#2013-10-27 21:03:18#
7#2013-11-07-527ba36a16888.html#<p>数据库是一种十分复杂的软件，它为用户提供了可靠的数据存储与查询机制，本文将来探讨一下其中的“可靠存储”这个问题。数据库的可靠存储特性主要体现在如下几个方面：</p> <ol> <li>当出现硬件错误时，保证数据的一致性  <li>保证一系列的操作是原子的，要么成功要么失败  <li>当数据备份多处时，保证不同数据备份的一致性</li></ol> <p>&nbsp;</p> <h2>单库事务控制，预写日志</h2> <p>数据一致性经常也被称为“事务一致性”，也就是保证一系列的操作，要么都成功要么都失败。例如有下面的关系数据表，存储了用户的账户信息：</p> <table class="table"> <tbody> <tr> <td valign="top" width="133"><strong>账户名称</strong></td> <td valign="top" width="133"><strong>账户类型</strong></td> <td valign="top" width="133"><strong>账户余额</strong></td></tr> <tr> <td valign="top" width="133">扎迪</td> <td valign="top" width="133">支票</td> <td valign="top" width="133">800</td></tr> <tr> <td valign="top" width="133">扎迪</td> <td valign="top" width="133">存款</td> <td valign="top" width="133">300</td></tr> <tr> <td valign="top" width="133">皮德罗</td> <td valign="top" width="133">支票</td> <td valign="top" width="133">150</td></tr></tbody></table> <p>现在希望将扎迪的支票账户中的200元转移到扎迪存款账户里，最终结果希望是</p> <table class="table"> <tbody> <tr> <td valign="top" width="133"><strong>账户名称</strong></td> <td valign="top" width="133"><strong>账户类型</strong></td> <td valign="top" width="133"><strong>账户余额</strong></td></tr> <tr> <td valign="top" width="133">扎迪</td> <td valign="top" width="133">支票</td> <td valign="top" width="133"><font color="%hff0000"><strong>600</strong></font></td></tr> <tr> <td valign="top" width="133">扎迪</td> <td valign="top" width="133">存款</td> <td valign="top" width="133"><font color="%hff0000"><strong>500</strong></font></td></tr> <tr> <td valign="top" width="133">皮德罗</td> <td valign="top" width="133">支票</td> <td valign="top" width="133">150</td></tr></tbody></table> <p>那么，我们需要将这个任务分两步来执行：</p> <ol> <li>先将扎迪的支票账户更新为600  <li>再将扎迪的存款账户更新为500</li></ol> <p>但是，如果这两个步骤不能保证，要么同时成功要么同时失败的话，将出现很严重的后果。比如：当完成第一步后，突然断电了，扎迪会发现他的支票账户少了200元，但是存款账户仍然是300，凭空少了200元！尽管说，像断电这样的都是小概率事件，但是在上面这个例子中是绝对不被允许的。</p> <p>在数据库中为了解决这个问题，提出了事务的概念，程序员可以将两个步骤包装在一个事务中提交给数据库，数据库能够保证“事务一致性”。这样神奇的效果是如何实现的呢？其实原理很简单，就是所谓的“<strong>预写日志</strong>”，我们来看下具体的过程</p> <p>程序员在程序中依次将下面的指令发送给数据库，以完成更新</p> <ol> <li>开始事务  <li>将扎迪的支票账户余额<font color="%hff0000"><strong>变为600</strong></font>  <li>将扎迪的存款账户余额<strong><font color="%hff0000">变成500</font></strong>  <li>结束事务</li></ol> <p>这些指令被数据库程序接收后，将在转化为如下操作：</p> <ol> <li>开始事务  <li>将扎迪的支票账户余额<font color="%hff0000"><strong>从800变为600</strong></font>  <li>将扎迪的存款账户余额<strong><font color="%hff0000">从300变成500</font></strong>  <li>结束事务</li></ol> <p>数据库并不是立刻执行事务中的操作，而是将这些操作依次写入“预写日志”，预写日志是保存在磁盘上的。随后，数据库程序将执行“预写日志”中的内容，将更新操作体现在数据文件中。在正常的情况下，当完成“结束事务”操作后，删除上面的日志，并告知程序执行成功，这样，正常的操作就完成了。（有些数据库会在日志删除前再次写入“归档日志”中，以便可以通过归档日志恢复整个库）</p> <p>这里有一个需要注意的问题，程序在将事务操作发送给数据库的过程中，数据库也可能崩溃，也就是说“预写日志”可能记录不完整。这样，当数据库从崩溃中重启后可能发生的两种情况：</p> <ul> <li>数据库崩溃重启后，查看预写日志，发现一个事务，并且该事务的最后一个操作是“结束事务”。那么此时可以推断：这个事务有可能执行成功了，但日志没来得及删除；也有可能这个事务没有执行完，甚至还没有执行。不过无论如何，数据库将进行“<font color="%hff0000"><strong>前滚</strong></font>”恢复，将事务中剩下操作执行一遍。但是问题是，怎么才能知道究竟执行到哪一步了呢？事实上，这一点根本不重要，因为哪怕重新回放整个预写日志中的内容也仍然可以达到一致性。对于这种无论执行多少次都不会影响最终结果的特性称为“<font color="%hff0000"><strong>幂等</strong></font>”。  <li>数据库崩溃重启后，查看预写日志，发现一个事务，并且该事务的最后一个操作不是“结束事务”。那么可以推断：可能是程序指令在发送到数据库的过程中，数据库崩溃了，而且事务一定没有正确执行。这个时候由于无法确定，这个事务后面时候还有其他的操作没有接收，所以数据库只能执行“<font color="%hff0000"><strong>回滚</strong></font>”恢复，将已经在日志中的操作反过来恢复。读者可能已经注意到了，数据库在记入预写日志的时候，不仅记录的新值，同时还记录的原值，这样就能将数据回退到初始状态。</li></ul> <p>这里实际上解释了两个概念：前滚和回滚，这是数据库事务控制中很重要的概念，读者可以自行查询其他资料以便了解更多的细节。</p> <p>&nbsp;</p> <h2>跨库事务控制，二阶段提交</h2> <p>在很多数据库系统中，不仅支持单库的事务一致性，还支持多个库的事务一致性，虽然不同的数据库产品在实现这个功能的时候，所使用的细节技术不同，但是大致都是采用了”二阶段提交“这个方法，下面我们来看下它是如何工作的。</p> <p>一般来说，多个库中在一次事务中需要有一个事务发起者，称为”主库”，其他的库称为“从库”。假设需要执行一个在所有库的某个表中插入一行数据的事务。</p> <ul> <li>第一阶段，主库锁定表，并将事务写入自己的预写日志；主库将事务发给从库，从库也各自锁定自己的表，并把事务写入预写日志，完成后返回告诉主库一阶段完成  <li>第二阶段，主库开始执行自己的事务，并通知从库提交事务。如果在这个过程中没有任何错误，那么操作将在多个库中完成；如果发生错误，比如从库锁表失败，或者从库没有响应，或者从库磁盘满…主库将通知所有参与事务的从库回滚该事务，并且回滚主库的事务。回滚就是根据预写日志的内容回滚事务的操作，可见预写日志的重要性。</li></ul> <p>下图分别展示了两种过程</p> <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="WOTV@KHBEKPVL2IP7{1LAVN" border="0" alt="WOTV@KHBEKPVL2IP7{1LAVN" src="http://fakelocalhost/assert/img/2013-11-10-527ef3942296b.jpeg" width="270" height="552">  <p>成功的二阶段提交，A为主库，B、C为从库  <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" class="img-responsive" title="WPNN6Z0_VS9RVUMJ`}UCBO8" border="0" alt="WPNN6Z0_VS9RVUMJ`}UCBO8" src="http://fakelocalhost/assert/img/2013-11-10-527ef39432b3f.jpeg" width="271" height="553">  <p>失败的二阶段提交，A为主库，B、C为从库</p> <p>&nbsp;</p> <h2>总结</h2> <p>可见，“预写日志”对于事务前滚或回滚来说是非常重要的，这个精巧的设计保证了数据库的“一致性”，进而保证了“可靠存储”。而“二阶段提交”也是一个十分精巧而简单的方法，在数据库的“主从复制”、“跨库事务”等方面都有应用。</p> <p>不过事实上，上面的讨论都是基于单用户的，但数据库还需要解决多用户并发问题，这是通过“锁”的机制来实现的，锁也同样重要，不过本文不再阐述。</p>#数据库一致性原理浅析#postlayout#数据库一致性是数据库非常重要的特性，高端的数据库产品往往也是在一致性上，下了很多功夫，本文从单库一致性和多库一致性两个方面介绍了数据库的实现原理#W020110914489795789471.jpg#[algorithm]#[database,consistency]#2013-11-07 22:27:54#2013-11-10 11:04:03#
8#2013-11-10-527f6ec41d6ad.html#<p>Require.js是一个支持javascript模块化编程的类库，不了解的读者请移步至：<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank">Javascript模块化编程（三）：require.js的用法</a>。</p> <p>require在单页面应用中能够如鱼得水，然而对于传统的多页面应用，使用require多少会有些困惑和不方便。</p> <p>多页面应用的一个典型的例子是<a href="https://github.com/requirejs/example-multipage">https://github.com/requirejs/example-multipage</a>，读者可以clone下来参考。本文参考这个例子在ASP.NET MVC的结构中应用require，并且给出了压缩脚本，实现半自动化压缩。</p> <h2>将js代码分离</h2> <p>一般而言ASP.NET MVC的一个路由对应一个视图，视图的文件结构可能如下：</p><pre>Views%n |--Shared%n     |--_layout.cshtml%n |--Home%n     |--Index.cshtml%n |--Blog%n     |--Create.cshtml%n     |--Edit.cshtml%n     |--Detail.cshtml%n     |--Index.cshtml%n</pre>%n<p>这里假设<code>_layout.cshtml</code>是所有页面共享的。一般情况下，我们会在_layout中引用公共的js类库，比如<strong>jQuery</strong>，<strong>bootstrap</strong>等，这样的话其他的页面就不需要对这些类库再引用一遍，提高了编码的效率。然而，不同的页面终究会依赖不同的js，尤其是实现页面本身功能的自定义的js，这样我们不得不在其他页面中再引用特殊的js，甚至将js直接写在页面中，例如下面的代码经常会出现在View中：</p><pre>&lt;script type="text/javascript"&gt;%n   $(function(){...});%n&lt;/script&gt;%n</pre>%n<p>这样会导致页面比较混乱，而且页面&lt;script&gt;标签中代码不能被浏览器缓存，增加了页面代码的长度。更为重要的缺陷是，诸如jQuery之类的类库会在加载到页面后执行匿名函数，这需要一些时间，而如果有些页面根本不需要jQuery的话，只要页面把_layout作为布局页面，那么jQuery的初始化代码将不可避免的执行，这是一种浪费。事实上，javascript的模块化加载的思想就是为了解决这些问题的。</p>%n<p>接下来我们来用require规划我们的js，构建诸如下面结构的js目录</p><pre>js%n|--app%n    |--home.index.js%n    |--blog.create.js%n    |--blog.edit.js%n    |--blog.detail.js%n    |--blog.index.js%n|--jquery.js%n|--bootstrap.js%n|--underscore.js%n|--jquery.ui.js%n|--jquery.customplugin.js%n|--config.js%n|--require.js%n</pre>%n<p>把公共的类库级别的js模块直接放在js目录下，而把页面级别的js放在一个app的子目录下。注意，在app中，每个页面一个js文件，这意味着我们需要把页面各自的js提取出来，虽然这样增加了结构复杂度，但是避免了在页面中随手写&lt;script&gt;标签的陋习。另外，在js目录下的公共库，除了第三方的库，还包括自己开发的库，还有一个叫<code>config.js</code>的文件，这个文件很关键，稍后会说到。</p>%n<p>然后，我们可以删除_layout中所有的js引用，并使用@RenderSection的命令要求子页面提供js引用：</p>%n<p><em><font color="%hff0000">_layout.cshtml</font></em></p><pre>&lt;head&gt;%n...%n@RenderSection("require_js_module", false)%n...%n&lt;/head&gt;%n</pre>%n<p>这样对js的需求就下放到每个view页面中了，根据require的用法，我们需要在各个子View中引用require.js，并指定主模块，而这些主模块就是上面app目录下的一个个js</p><pre>@section require_js_module{%n    &lt;script src="@Url.Content("~/js/require.js")" data-main="@Url.Content("~/js/app/home.index.js")" &gt;&lt;/script&gt;%n}%n</pre>%n<p>所有的js代码都将写到app下的js中，这样规范了js，使得页面更干净，更为重要的是这些js还可以经过压缩，以及被浏览器缓存等，进一步提高执行效率</p>%n<h2>公共的config</h2>%n<p>我们知道主模块除了使用<code>require</code>方法外，经常需要通过<code>require.config</code>来配置其他模块的路径，甚至需要<code>shim</code>，例如下面的代码经常会出现在主模块的开头：</p><pre>require.config({%n	paths: {%n　　　　　　"jquery": "lib/jquery.min",%n　　　　　　"underscore": "lib/underscore.min",%n　　　　　　"backbone": "lib/backbone.min"%n　　　　},%n　　　　shim: {%n　　　　　　'underscore':{%n　　　　　　　　exports: '_'%n　　　　　　},%n　　　　　　'backbone': {%n　　　　　　　　deps: ['underscore', 'jquery'],%n　　　　　　　　exports: 'Backbone'%n　　　　　　}%n　　　　}%n　　});%n</pre>%n<p>对于单页面应用来说，主模块往往只有一个，所以上面的代码写一遍也就OK了。但是，在多页面的情况下，主模块有多个，每个主模块都要包含这样的代码，岂不是很不科学？于是，希望有一个统一配置的地方，但是应该如何来写呢？我们想到，将这些配置作为一个模块config.js，让其他的主模块对这个模块产生依赖就可以了，例如下面的config.js：</p>%n<p><em><font color="%hff0000">config.js</font></em></p><pre>requirejs.config({%n	paths: {%n　　　　　　"jquery": "/js/jquery.min",%n	    "bootstrap": "/js/bootstrap"%n　　　　},%n　　　　shim: {%n	    'bootstrap': {%n                deps: ['jquery'],%n                exports: "jQuery.fn.popover"%n            }%n　　　　}%n　　});%n%n</pre>%n<p>config.js的写法没有什么特别的，接下来只要在home.index.js中引用</p>%n<p><em><font color="%hff0000">home.index.js</font></em></p><pre>require(['../config','jquery', 'bootstrap'], function () {%n    //main module code here%n%n});%n</pre>%n<p>不过这样写还是不对的，因为，被主模块依赖的模块(这里的config,jquery,bootstrap)，在加载的时候，加载顺序是不确定的，但是又需要config模块在其他模块之前加载，怎么办呢？一个折衷的方案是修改home.index.js，成为如下代码：</p>%n<p><em><font color="%hff0000">home.index.js</font></em></p><pre>require(['../config'], function () {%n    require(['home.index2']);%n})%n, define("home.index2", ['jquery', 'bootstrap'], function () {%n	//main module code here%n})%n</pre>%n<p>使用一个命名的模块home.index2作为过渡，在主模块中手动require，这样可以保证config在主模块执行之前加载，也就使得home.index2在加载的时候已经加载了config了。</p>%n<h2>压缩</h2>%n<p>require提供一个压缩工具，用于压缩和合并js，详情请移步至<a href="http://requirejs.org/docs/optimization.html">http://requirejs.org/docs/optimization.html</a>。简单的说，require提供一个叫<code>r.js</code>的文件，通过本地的node程序（Node.js），执行这个r.js并传入一些参数，即可自动分析模块互相之间的依赖，以达到合并和压缩的目的。同样的，这对于单页面应用来说是容易的，因为主模块只有一个，但是对于多页面又如何做呢？好在这个压缩工具支持用一个配置文件来指导压缩，这样的话，我们可以编写下面的配置脚本：</p>%n<p><em><font color="%hff0000">build.js</font></em></p><pre>var build = {%n    appDir: '../js',%n    baseUrl: '.',%n    dir: '../js-built',%n    modules: [%n        //First set up the common build layer.%n        {%n            //module names are relative to baseUrl%n            name: 'config',%n            //List common dependencies here. Only need to list%n            //top level dependencies, "include" will find%n            //nested dependencies.%n            include: ["bootstrap", "config","jquery"]%n        },%n	//Now set up a build layer for each page, but exclude%n        //the common one. "exclude" will exclude nested%n        //the nested, built dependencies from "common". Any%n        //"exclude" that includes built modules should be%n        //listed before the build layer that wants to exclude it.%n        //"include" the appropriate "app/main*" module since by default%n        //it will not get added to the build since it is loaded by a nested%n        //require in the page*.js files.%n	{%n	    name:"app/home.index",%n	    exclude:["config"]%n	},%n	{%n	    name:"app/blog.create",%n	    exclude:["config"]%n	},%n	...%n    ]%n%n}%n</pre>%n<p>通过这个命令来执行压缩，压缩的结果将被保存到js-build目录：</p><pre>node.exe r.js -o build.js%n</pre>%n<p>build.js脚本实际上是一个js对象，我们将config加入公共模块，而在各个主模块中将其排除。这样，所有的公共库包括config将压缩成一个js，而主模块又不会包含多余的config。这样可想而知，每个页面在加载时最多只会下载两个js，而且公共模块的代码会“按需执行”。</p>%n<p>执行上面的脚本压缩，需要安装有node。可以在从这里<a href="http://nodejs.org/download/" target="_blank">下载</a>。</p>%n<h2>自动脚本</h2>%n<p>但是，随着主模块的增加，需要随时跟踪和修改这个build文件，这也是很麻烦的。于是，笔者基于node.js开发了一个叫<code>build-build.js</code>的脚本，用来根据目录结构自动生成build.js：</p>%n<p><em><font color="%hff0000">build-build.js</font></em></p><pre>fs = require('fs');%nvar target_build = process.argv[2];%n//console.log(__filename);%nvar pwd = __dirname;%nvar js_path = pwd.substring(0,pwd.lastIndexOf('\\')) + '\\js';%nconsole.log('js path : ' + js_path);%nvar app_path = js_path + '\\app';%nconsole.log('js app path : ' +app_path);%n%nvar app_modules = [];%nvar global_modules = [];%n%n//build json object%nvar build = {%n	appDir: '../js',%n    baseUrl: '.',%n    dir: '../js-built',%n    modules: [%n        //First set up the common build layer.%n        {%n            //module names are relative to baseUrl%n            name: 'config',%n            //List common dependencies here. Only need to list%n            //top level dependencies, "include" will find%n            //nested dependencies.%n            include: []%n        }%n    ]%n}%n%nfs.readdir(app_path,function (err,files) {%n	// body...%n	if (err) throw err;%n	for(var i in files){%n		//put module in app_modules%n		var dotindex = files[i].lastIndexOf('.');%n		if(dotindex &gt;= 0){%n			var extension = files[i].substring(dotindex+1,files[i].length);%n			if(extension == 'js'){%n				app_modules.push({%n					name: 'app/' + files[i].substring(0,dotindex),%n            		exclude: ['config']%n				});%n			}%n		}%n	}%n%n	for(var j in app_modules){%n		build.modules.push(app_modules[j]);%n	}%n	%n	fs.readdir(js_path,function (err,files){%n		if (err) throw err;%n		for(var i in files){%n			//put module in app_modules%n			var dotindex = files[i].lastIndexOf('.');%n			if(dotindex &gt;= 0){%n				var extension = files[i].substring(dotindex+1,files[i].length);%n				if(extension == 'js'){%n					global_modules.push(files[i].substring(0,dotindex));%n				}%n			}	%n		}%n%n		build.modules[0].include = global_modules;%n		//console.log(build);%n		var t = pwd + '\\' + target_build;%n		console.log(t);%n		var fd = fs.openSync(t, 'w');%n		fs.closeSync(fd);%n		var json = JSON.stringify(build);%n		fs.writeFileSync(t, json);%n	});%n});%n</pre>%n<p>这里的代码并不复杂，主要是遍历目录，生成对象，最后将对象序列化为build.js。读者可以自行阅读并修改。最后，编写一个bat，完成一键压缩功能：</p>%n<p><em><font color="%hff0000">build.bat</font></em></p><pre>@echo off%nset PWD=%p~p0%nset PWD=%pPWD:\=/%p%ncd "D:\node"%nnode.exe %pPWD%pbuild-build.js build.js%nnode.exe %pPWD%pr.js -o %pPWD%pbuild.js%ncd %p~dp0%n</pre>%n<p>这样，我们就简单实现了一个方便的多页面require方案，最后项目目录可能是这样的：</p><pre>Views%n |--Shared%n     |--_layout.cshtml%n |--Home%n     |--Index.cshtml%n |--Blog%n     |--Create.cshtml%n     |--Edit.cshtml%n     |--Detail.cshtml%n     |--Index.cshtml%n%nbuild%n|--build.js%n|--r.js%n|--build-build.js%n|--build.bat%n%njs%n|--app%n    |--home.index.js%n    |--blog.create.js%n    |--blog.edit.js%n    |--blog.detail.js%n    |--blog.index.js%n|--jquery.js%n|--bootstrap.js%n|--underscore.js%n|--jquery.ui.js%n|--jquery.customplugin.js%n|--config.js%n|--require.js%n</pre>%n<p>可以从<a href="https://github.com/PChou/mvc-require-mutilpage-example" target="_blank">这里</a>fork示例程序</p>#ASP.NET MVC应用require.js实践#postlayout#本文探讨如何在ASP.NET MVC多页面环境下应用js的模块化编程框架require，并给出压缩相关的自动化脚本#require_logo.png#[javascript,asp.net]#[require.js,asp.net mvc,node.js]#2013-11-10 19:32:20#2013-11-11 13:30:11#